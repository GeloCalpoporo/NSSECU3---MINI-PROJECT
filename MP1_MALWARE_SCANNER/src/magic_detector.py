"""
File Signature / Magic Number Detector
Source: Gary Kessler's File Signatures Table [citation:8]
"""
import struct
from pathlib import Path
from typing import Optional, Dict, List, Tuple

class MagicNumberDetector:
    """
    Detects file types using magic numbers/headers.
    Implements signatures from GCK'S FILE SIGNATURES TABLE [citation:8]
    """
    
    # File signatures database (offset 0 hex codes)
    # Format: (hex_pattern, extension, description, offset)
    SIGNATURES = [
        # Images
        (b'\xFF\xD8\xFF', 'jpg', 'JPEG image', 0),
        (b'\x89PNG\r\n\x1A\n', 'png', 'PNG image', 0),
        (b'GIF87a', 'gif', 'GIF 87a', 0),
        (b'GIF89a', 'gif', 'GIF 89a', 0),
        (b'BM', 'bmp', 'BMP image', 0),
        
        # Documents
        (b'%PDF', 'pdf', 'PDF document', 0),
        (b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1', 'doc', 'MS Office/OLE2', 0),  # Old Office
        (b'PK\x03\x04', 'docx', 'Office Open XML', 0),  # Also zip-based
        (b'{\\rtf', 'rtf', 'Rich Text Format', 0),
        
        # Executables
        (b'MZ', 'exe', 'PE executable', 0),
        (b'\x7FELF', 'elf', 'ELF executable', 0),
        
        # Archives
        (b'PK\x03\x04', 'zip', 'ZIP archive', 0),
        (b'Rar!\x1A\x07', 'rar', 'RAR archive', 0),
        (b'\x1F\x8B', 'gz', 'GZIP archive', 0),
        (b'7z\xBC\xAF\x27\x1C', '7z', '7-Zip archive', 0),
        
        # Others
        (b'<!DOCTYPE', 'xml', 'XML document', 0),
        (b'<?xml', 'xml', 'XML document', 0),
        (b'<html', 'html', 'HTML document', 0),
    ]
    
    @classmethod
    def detect(cls, file_path: Path) -> Dict[str, str]:
        """
        Detect file type based on magic numbers.
        
        Args:
            file_path: Path to file
            
        Returns:
            Dict with 'extension', 'description', 'confidence'
        """
        try:
            with open(file_path, 'rb') as f:
                header = f.read(32)  # Read enough for all signatures
                
            for sig_bytes, ext, desc, offset in cls.SIGNATURES:
                if offset + len(sig_bytes) <= len(header):
                    if header[offset:offset + len(sig_bytes)] == sig_bytes:
                        return {
                            'extension': ext,
                            'description': desc,
                            'magic': sig_bytes.hex()[:16],
                            'confidence': 'HIGH'
                        }
            
            # Try text detection
            try:
                with open(file_path, 'r', encoding='ascii') as f:
                    f.read(100)
                return {
                    'extension': 'txt',
                    'description': 'ASCII text',
                    'magic': 'none',
                    'confidence': 'MEDIUM'
                }
            except UnicodeDecodeError:
                pass
                
            return {
                'extension': 'bin',
                'description': 'Binary data',
                'magic': header[:8].hex(),
                'confidence': 'LOW'
            }
            
        except Exception as e:
            return {
                'extension': 'unknown',
                'description': f'Error: {str(e)}',
                'magic': '',
                'confidence': 'NONE'
            }
    
    @classmethod
    def get_all_signatures(cls) -> List[Dict]:
        """Return all supported signatures for reporting."""
        return [
            {'hex': sig.hex(), 'ext': ext, 'desc': desc}
            for sig, ext, desc, _ in cls.SIGNATURES
        ]